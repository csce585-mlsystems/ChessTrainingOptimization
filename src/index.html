<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --current-board-dimension: 600px; 
            --board-padding-scale: 0.025; 
            --board-border-scale: 0.0035; 
            --board-radius-scale: 0.013;  
            --label-font-min-scale: 0.02;   
            --label-font-pref-scale: 0.025; 
            --label-font-max-scale: 0.03;   
            --piece-fallback-font-min-scale: 0.04;
            --piece-fallback-font-pref-scale: 0.065;
            --piece-fallback-font-max-scale: 0.085;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; 
            color: #e2e8f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            overflow-x: hidden; 
        }

        .main-game-layout {
            display: flex;
            flex-direction: row;
            gap: 20px;
            width: 100%;
            max-width: 1200px; 
            align-items: flex-start; 
        }

        .board-and-player-info-column {
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex-grow: 1; 
            min-width: 0; 
        }

        .sidebar-column {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 240px; 
            flex-shrink: 0; 
        }
       
        .player-area {
            background-color: #2d3748;
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
        }
        .player-details { 
            flex-grow: 1;
            min-width: 0; 
        }
        .player-name {
            font-size: 1.1em;
            font-weight: 600;
            margin-bottom: 3px; 
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .player-score {
            font-size: 0.9em;
            color: #9ca3af; 
            min-height: 1.2em; 
            margin-bottom: 5px;
        }
        .captured-pieces {
            min-height: 28px; 
            padding-top: 5px;
            text-align: left;
            font-size: 0.9em; 
            color: #a0aec0;
            overflow-x: auto; 
            white-space: nowrap;
            display: flex; 
            flex-wrap: wrap; 
            align-items: center; 
        }
        .captured-pieces-label {
            margin-right: 8px;
            font-style: italic;
        }
        .captured-pieces .piece-image { 
            height: 20px; 
            width: 20px;
            margin-right: 1px; 
            margin-bottom: 2px; 
            object-fit: contain;
        }
         .captured-pieces .piece-char-fallback { 
            margin-right:1px; font-weight:bold; font-size: 0.9em;
         }
         .captured-by-player-top .piece-char-fallback { color: #f0f0f0; } 
         .captured-by-player-bottom .piece-char-fallback { color: #1a202c; } 

        .player-clock-area { 
            text-align: center;
            margin-left: 15px; 
        }
        .clock-label { font-size: 0.8em; color: #9ca3af; margin-bottom: 2px; }
        .clock {
            font-size: 1.5em; 
            font-weight: bold; 
            padding: 6px 10px; 
            background-color: #374151; 
            border-radius: 6px; 
            min-width: 90px; 
        }
        .clock.active { border: 2px solid #63b3ed; }


        .game-setup-container, .game-controls, .game-status-area, .fen-io-container, .ai-controls-container, .position-setup-container { 
            background-color: #2d3748;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
            width: 100%;
        }
        .time-controls label { margin-right: 10px; font-weight: 500; }
        .time-controls input[type="radio"] { margin-right: 5px; }
        #flip-board-btn {
            background-color: #4a5568; color: white; font-size: 1.5rem; 
            padding: 8px 12px; border: none; border-radius: 6px; cursor: pointer;
            transition: background-color 0.2s ease; display: block; 
        }
        #flip-board-btn:hover { background-color: #2c5282; }


        .chessboard-container {
            position: relative; 
            display: grid;
            grid-template-areas: ". top ." "left board right" ". bottom .";
            grid-template-columns: auto minmax(0, 1fr) auto; 
            grid-template-rows: auto minmax(0, 1fr) auto;    
            gap: calc(var(--current-board-dimension) * 0.01); 
            align-items: center; justify-items: center;
            background-color: #2d3748; 
            padding: calc(var(--current-board-dimension) * var(--board-padding-scale)); 
            border-radius: calc(var(--current-board-dimension) * 0.02); 
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05);
            width: var(--current-board-dimension); 
            max-width: 100%; 
            aspect-ratio: 1 / 1; 
            user-select: none; 
        }
        #resize-handle {
            position: absolute;
            bottom: -5px; 
            right: -5px;  
            width: 20px;
            height: 20px;
            background-color: rgba(113, 128, 150, 0.7); 
            border: 1px solid #4a5568; 
            border-radius: 50%;
            cursor: nwse-resize;
            z-index: 20; 
        }
        #resize-handle:hover {
            background-color: rgba(74, 85, 104, 0.9); 
        }

        .file-labels-top { grid-area: top; } .rank-labels-left { grid-area: left; }
        #chessboard-wrapper { grid-area: board; position: relative; width: 100%; height: 100%;} /* Wrapper for board and canvas */
        #chessboard { 
            /* Removed grid-area: board; as it's now on the wrapper */
            /* Added position absolute for stacking context if needed, but direct child of wrapper should be fine */
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
        } 
        #arrowCanvas {
            /* Removed grid-area: board; */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows clicks to pass through to the board */
            z-index: 3; /* Above board squares, below selected highlights if any */
        }
        .rank-labels-right { grid-area: right; }
        .file-labels-bottom { grid-area: bottom; }

        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, minmax(0, 1fr));
            grid-template-rows: repeat(8, minmax(0, 1fr));
            width: 100%; 
            height: 100%; 
            border-style: solid;
            border-color: #4a5568;
            border-width: calc(var(--current-board-dimension) * var(--board-border-scale)); 
            border-radius: calc(var(--current-board-dimension) * var(--board-radius-scale)); 
        }
        .square {
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: background-color 0.2s ease-in-out;
            position: relative; 
            user-select: none; 
            -webkit-user-select: none; 
            -moz-user-select: none; 
            -ms-user-select: none; 
        }
        .square.light { background-color: #f9fafb; } 
        .square.dark { background-color: #374151; } 
        .square.selected { background-color: #63b3ed !important; outline-style: solid; outline-color: #2c5282; outline-width: calc(var(--current-board-dimension) * 0.005); z-index: 10; }
       
        .square.highlight-move-dot::before {
            content: ''; position: absolute; left: 50%; top: 50%;
            width: calc(var(--current-board-dimension) * 0.02); 
            height: calc(var(--current-board-dimension) * 0.02);
            background-color: rgba(0,0,0,0.35); 
            border-radius: 50%; transform: translate(-50%, -50%); z-index: 0; 
        }
        .square.highlight-capture-ring::before {
            content: ''; position: absolute; left: 50%; top: 50%;
            width: 80%; height: 80%; 
            border-style: solid;
            border-color: rgba(20,20,20,0.5); 
            border-width: calc(var(--current-board-dimension) * 0.005); 
            border-radius: 50%; transform: translate(-50%, -50%);
            box-sizing: border-box; z-index: 0; 
        }
        .square.last-move-from, .square.last-move-to { background-color: rgba(250,204,21,0.5) !important; }
       
        .piece-image { 
            width: 85%; height: 85%; 
            object-fit: contain; display: block; 
            margin: auto; user-select: none; 
            position: relative; z-index: 1; 
            cursor: grab; 
        }
        .piece-image.lifted { 
            visibility: hidden;
        }
        .piece-char-fallback-board { 
            font-weight: bold; 
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
            font-size: clamp(
                calc(var(--current-board-dimension) * var(--piece-fallback-font-min-scale)), 
                calc(var(--current-board-dimension) * var(--piece-fallback-font-pref-scale)), 
                calc(var(--current-board-dimension) * var(--piece-fallback-font-max-scale))
            );
        }
        .piece-char-fallback-board.white { color: #f0f0f0; } .piece-char-fallback-board.black { color: #1a202c; }

        .rank-labels-left, .rank-labels-right { 
            display: grid; grid-template-rows: repeat(8,1fr); height: 100%; align-items: center; 
            width: calc(var(--current-board-dimension) * 0.05); 
        }
        .file-labels-top, .file-labels-bottom { 
            display: grid; grid-template-columns: repeat(8,1fr); width: 100%; align-items: center; 
            height: calc(var(--current-board-dimension) * 0.05); 
        }
        .rank-label, .file-label { 
            color: #a0aec0; display: flex; align-items: center; justify-content: center; 
            font-size: clamp(
                calc(var(--current-board-dimension) * var(--label-font-min-scale)), 
                calc(var(--current-board-dimension) * var(--label-font-pref-scale)), 
                calc(var(--current-board-dimension) * var(--label-font-max-scale))
            );
        }

        .game-controls button, .fen-io-container button, .ai-controls-container button, .position-setup-container button {
            background-color: #4a5568; color: #e2e8f0; padding: 10px 15px; border: none;
            border-radius: 6px; font-weight: 600; cursor: pointer; transition: background-color 0.2s ease; margin-top: 5px;
        }
        .game-controls button:hover, .fen-io-container button:hover, .ai-controls-container button:hover, .position-setup-container button:hover { background-color: #2c5282; }
       
        .status-message { min-height: 24px; font-weight: 600; color: #9ae6b4; margin-bottom: 10px;}

        .move-history-container {
            max-height: 150px; overflow-y: auto; background-color: #1f2937; 
            border-radius: 4px; padding: 8px; margin-bottom: 10px;
        }
        .move-history-list { list-style: none; padding: 0; margin: 0; font-size: 0.9em; }
        .move-history-list li { padding: 2px 4px; border-bottom: 1px solid #374151; cursor: pointer; }
        .move-history-list li:last-child { border-bottom: none; }
        .move-history-list li.current-history-view { background-color: #4b5563; font-weight: bold; }
        .move-history-controls { display: flex; justify-content: space-between; margin-top: 5px; }
        .move-history-controls button {
            background-color: #4a5568; color: white; padding: 6px 10px;
            border:none; border-radius: 4px; cursor: pointer;
        }
        .move-history-controls button:disabled { background-color: #374151; cursor: not-allowed; }

        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); align-items: center; justify-content: center; }
        .modal-content { background-color: #2d3748; margin: auto; padding: 30px; border: 1px solid #4a5568; width: 80%; max-width: 400px; border-radius: 12px; text-align: center; box-shadow: 0 10px 25px rgba(0,0,0,0.3); }
        .modal-content p { margin-bottom: 20px; font-size: 1.1em; }
        .modal-content textarea { background-color: #1a202c; color: #e2e8f0; border: 1px solid #4a5568; border-radius: 4px; padding: 8px; width: calc(100% - 16px); margin-bottom:10px; }
        .modal-close-button, .fen-copy-button { background-color: #4a5568; color: #e2e8f0; padding: 10px 20px; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; transition: background-color 0.2s ease; margin-left: 5px; }
        .modal-close-button:hover, .fen-copy-button:hover { background-color: #2c5282; }
       
        .fen-io-container input[type="text"] {
            width: calc(100% - 110px); 
            padding: 10px;
            margin-right: 5px;
            border-radius: 6px;
            border: 1px solid #4a5568;
            background-color: #1f2937;
            color: #e2e8f0;
        }
        .ai-toggle-btn.active { background-color: #38a169; }
        .ai-toggle-btn.inactive { background-color: #c53030; }

        #piece-palette {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 10px;
            background-color: #1f2937;
            border-radius: 6px;
            margin-top: 10px;
            border: 1px solid #4a5568;
        }
        .palette-piece {
            width: 40px;
            height: 40px;
            cursor: grab;
            border: 1px solid #4a5568;
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #2d3748;
        }
        .palette-piece img { width: 80%; height: 80%; object-fit: contain; }
        .position-setup-container button { width: calc(50% - 5px); } 
        .position-setup-container > .w-full { width: 100%; } 


    </style>
</head>
<body>
    <h1 class="text-3xl font-bold mb-4 text-center">Chess Game</h1>

    <div class="main-game-layout">
        <div class="board-and-player-info-column">
            <div id="player-area-top" class="player-area">
                <div class="player-details">
                    <div id="player-name-top" class="player-name">Player 2 (Black)</div>
                    <div id="player-score-top" class="player-score"></div>
                    <div id="captured-for-player-top" class="captured-pieces">
                        <span class="captured-pieces-label">Captures:</span> None
                    </div>
                </div>
                <div id="player-clock-area-top" class="player-clock-area">
                </div>
            </div>

            <div class="chessboard-container" id="chessboard-container-resizable">
                <div class="file-labels-top" style="grid-area: top;"></div>
                <div class="rank-labels-left" style="grid-area: left;"></div>
                <div id="chessboard-wrapper" style="grid-area: board; position: relative; width: 100%; height: 100%;">
                    <div id="chessboard" class="chessboard"></div>
                    <canvas id="arrowCanvas"></canvas> </div>
                <div class="rank-labels-right" style="grid-area: right;"></div>
                <div class="file-labels-bottom" style="grid-area: bottom;"></div>
                <div id="resize-handle"></div>
            </div>

            <div id="player-area-bottom" class="player-area">
                 <div class="player-details">
                    <div id="player-name-bottom" class="player-name">Player 1 (White)</div>
                    <div id="player-score-bottom" class="player-score"></div>
                    <div id="captured-for-player-bottom" class="captured-pieces">
                        <span class="captured-pieces-label">Captures:</span> None
                    </div>
                </div>
                <div id="player-clock-area-bottom" class="player-clock-area">
                </div>
            </div>
        </div>

        <div class="sidebar-column">
            <div class="game-setup-container">
                <div class="time-controls">
                    <h2 class="text-lg mb-1 font-semibold">Time Control:</h2>
                    <div id="time-control-options">
                        <label><input type="radio" name="timeControl" value="0" checked> No Clock</label>
                        <label><input type="radio" name="timeControl" value="60"> 1 min</label>
                        <label><input type="radio" name="timeControl" value="300"> 5 min</label>
                        <label><input type="radio" name="timeControl" value="600"> 10 min</label>
                    </div>
                </div>
            </div>
           
            <button id="flip-board-btn" title="Flip Board Perspective" class="w-full">⇄</button>
           
            <div class="fen-io-container">
                <h2 class="text-lg mb-1 font-semibold">FEN:</h2>
                <div>
                    <input type="text" id="fen-input" placeholder="Enter FEN string...">
                    <button id="import-fen-btn">Import</button>
                </div>
                <button id="export-fen-btn" class="w-full">Export FEN</button>
            </div>

            <div class="position-setup-container">
                <h2 class="text-lg mb-1 font-semibold">Position Setup:</h2>
                <button id="setup-position-btn" class="w-full">Set Up Position</button>
                <div id="piece-palette-controls" class="hidden mt-2">
                    <div id="piece-palette"></div>
                    <div class="flex justify-between mt-2">
                        <button id="clear-board-setup-btn">Clear Board</button>
                        <button id="done-setting-up-btn">Done Setup</button>
                    </div>
                </div>
            </div>

            <div class="ai-controls-container">
                <h2 class="text-lg mb-1 font-semibold">AI Opponent:</h2>
                <button id="toggle-white-ai-btn" class="ai-toggle-btn inactive w-full">White AI: OFF</button>
                <button id="toggle-black-ai-btn" class="ai-toggle-btn inactive w-full mt-2">Black AI: OFF</button>
            </div>
           
            <div class="game-status-area"> 
                <h2 class="text-lg mb-2 font-semibold text-center">Game Info</h2>
                <div id="status-message" class="status-message">Select time control and start a new game.</div>
                <div class="move-history-container">
                    <ul id="move-history-list" class="move-history-list">
                        </ul>
                </div>
                <div class="move-history-controls">
                    <button id="prev-move-btn">← Prev</button>
                    <button id="next-move-btn">Next →</button>
                </div>
            </div>

            <div class="game-controls">
                <button id="new-game-btn" class="w-full">New Game</button> 
            </div>
        </div>
    </div>

    <div style="display: none;">
        <div id="clock-white-wrapper">
            <div class="clock-label">White</div>
            <div id="clock-white" class="clock">00:00</div>
        </div>
        <div id="clock-black-wrapper">
            <div class="clock-label">Black</div>
            <div id="clock-black" class="clock">00:00</div>
        </div>
    </div>


    <div id="messageModal" class="modal">
        <div class="modal-content">
            <p id="modalMessageText"></p>
            <button id="modalCloseButton" class="modal-close-button">Close</button>
        </div>
    </div>
   
    <div id="fenExportModal" class="modal">
        <div class="modal-content">
            <h3 class="text-lg leading-6 font-medium text-gray-200 mb-2">Current FEN String</h3>
            <textarea id="exported-fen-display" readonly class="w-full h-24 p-2"></textarea>
            <div class="mt-4 flex justify-end">
                <button type="button" id="copy-fen-btn" class="fen-copy-button">Copy</button>
                <button type="button" id="close-fen-export-modal-btn" class="modal-close-button">Close</button>
            </div>
        </div>
    </div>


    <script>
        // --- Constants and Configuration ---
        const BOARD_SIZE = 8;
        const PIECE_IMAGE_URLS = {
            'P': 'https://upload.wikimedia.org/wikipedia/commons/4/45/Chess_plt45.svg', 'R': 'https://upload.wikimedia.org/wikipedia/commons/7/72/Chess_rlt45.svg',
            'N': 'https://upload.wikimedia.org/wikipedia/commons/7/70/Chess_nlt45.svg', 'B': 'https://upload.wikimedia.org/wikipedia/commons/b/b1/Chess_blt45.svg',
            'Q': 'https://upload.wikimedia.org/wikipedia/commons/1/15/Chess_qlt45.svg', 'K': 'https://upload.wikimedia.org/wikipedia/commons/4/42/Chess_klt45.svg',
            'p': 'https://upload.wikimedia.org/wikipedia/commons/c/c7/Chess_pdt45.svg', 'r': 'https://upload.wikimedia.org/wikipedia/commons/f/ff/Chess_rdt45.svg',
            'n': 'https://upload.wikimedia.org/wikipedia/commons/e/ef/Chess_ndt45.svg', 'b': 'https://upload.wikimedia.org/wikipedia/commons/9/98/Chess_bdt45.svg',
            'q': 'https://upload.wikimedia.org/wikipedia/commons/4/47/Chess_qdt45.svg', 'k': 'https://upload.wikimedia.org/wikipedia/commons/f/f0/Chess_kdt45.svg'
        };
        const PIECE_FALLBACK_TEXT = { 'P': 'P', 'R': 'R', 'N': 'N', 'B': 'B', 'Q': 'Q', 'K': 'K', 'p': 'p', 'r': 'r', 'n': 'n', 'b': 'b', 'q': 'q', 'k': 'k' };
        const PIECE_ALT_TEXT = { 
            'P': 'White Pawn', 'R': 'White Rook', 'N': 'White Knight', 'B': 'White Bishop', 'Q': 'White Queen', 'K': 'White King',
            'p': 'Black Pawn', 'r': 'Black Rook', 'n': 'Black Knight', 'b': 'Black Bishop', 'q': 'Black Queen', 'k': 'Black King'
        };
        const PALETTE_PIECES_ORDER = ['K', 'Q', 'R', 'B', 'N', 'P', 'k', 'q', 'r', 'b', 'n', 'p'];

        const PYTHON_API_URL = 'http://127.0.0.1:5000'; 
        const MATERIAL_VALUES = { 'p': 1, 'n': 3, 'b': 3, 'r': 5, 'q': 9, 'k': 0 }; 
        const START_FEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
        const MIN_BOARD_DIMENSION = 300; 
        let MAX_BOARD_DIMENSION = Math.min(window.innerWidth - 280, window.innerHeight - 100); 


        // --- Game State ---
        let boardState = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null)); 
        let selectedSquare = null; 
        let draggedImageElement = null; 
        let generatedLegalMoves = []; 
        let currentPlayer = 'white'; 
        let gameOver = false;
        let gameTimeMode = 0; 
        let playerTimes = { white: 0, black: 0 };
        let activeTimerId = null;
        let capturedByWhite = []; 
        let capturedByBlack = []; 
        let boardFlipped = false; 
        let lastMove = null;
        let castlingRights = { 
            K: true, Q: true, k: true, q: true
        };
        let moveHistory = []; 
        let currentMoveIndexInHistory = -1; 
        let aiIsThinking = false; 
        let enPassantTargetSquare = null; 
        let halfmoveClock = 0; 
        let fullmoveNumber = 1; 
        let positionHistoryForRepetition = []; // For threefold repetition check

        let isSetupMode = false;
        let draggedPalettePiece = null; 
        let isWhiteAI = false;
        let isBlackAI = false;

        let isResizing = false;
        let initialMouseX, initialMouseY, initialBoardWidth;

        // --- Arrow Drawing State ---
        let arrowCanvas = null;
        let arrowCtx = null;
        let arrowsOnBoard = []; // Stores { from: {r, c}, to: {r, c}, color: string } in actual coordinates
        let isDrawingArrow = false;
        let arrowStartSquareVisual = null; // { visualRow, visualCol }
        let currentMouseSquareVisual = null; // { visualRow, visualCol } for preview


        // --- DOM Elements ---
        const chessboardContainerResizable = document.getElementById('chessboard-container-resizable');
        const resizeHandle = document.getElementById('resize-handle');
        const chessboardWrapper = document.getElementById('chessboard-wrapper'); // Wrapper for board and canvas
        const chessboardDiv = document.getElementById('chessboard');
        const statusMessageDiv = document.getElementById('status-message');
        const newGameBtn = document.getElementById('new-game-btn');
        const messageModal = document.getElementById('messageModal');
        const modalMessageText = document.getElementById('modalMessageText');
        const modalCloseButton = document.getElementById('modalCloseButton');
       
        const clockWhiteWrapper = document.getElementById('clock-white-wrapper');
        const clockBlackWrapper = document.getElementById('clock-black-wrapper');
        const clockWhiteDiv = document.getElementById('clock-white'); 
        const clockBlackDiv = document.getElementById('clock-black'); 

        const capturedForPlayerTopDiv = document.getElementById('captured-for-player-top');
        const capturedForPlayerBottomDiv = document.getElementById('captured-for-player-bottom');
        const playerNameTopDiv = document.getElementById('player-name-top');
        const playerNameBottomDiv = document.getElementById('player-name-bottom');
        const playerClockAreaTop = document.getElementById('player-clock-area-top');
        const playerClockAreaBottom = document.getElementById('player-clock-area-bottom');
        const playerScoreTopDiv = document.getElementById('player-score-top'); 
        const playerScoreBottomDiv = document.getElementById('player-score-bottom'); 
        const flipBoardBtn = document.getElementById('flip-board-btn');
        const moveHistoryListUl = document.getElementById('move-history-list');
        const prevMoveBtn = document.getElementById('prev-move-btn');
        const nextMoveBtn = document.getElementById('next-move-btn');

        const fenInput = document.getElementById('fen-input');
        const importFenBtn = document.getElementById('import-fen-btn');
        const exportFenBtn = document.getElementById('export-fen-btn');
        const fenExportModal = document.getElementById('fenExportModal');
        const exportedFenDisplay = document.getElementById('exported-fen-display');
        const copyFenBtn = document.getElementById('copy-fen-btn');
        const closeFenExportModalBtn = document.getElementById('close-fen-export-modal-btn');

        const setupPositionBtn = document.getElementById('setup-position-btn');
        const piecePaletteControlsDiv = document.getElementById('piece-palette-controls');
        const piecePaletteDiv = document.getElementById('piece-palette');
        const clearBoardSetupBtn = document.getElementById('clear-board-setup-btn');
        const doneSettingUpBtn = document.getElementById('done-setting-up-btn');

        const toggleWhiteAiBtn = document.getElementById('toggle-white-ai-btn');
        const toggleBlackAiBtn = document.getElementById('toggle-black-ai-btn');

        // --- Arrow Drawing Functions ---
        function initializeArrowCanvas() {
            arrowCanvas = document.getElementById('arrowCanvas');
            if (!arrowCanvas) {
                console.error("Arrow canvas not found!");
                return;
            }
            arrowCtx = arrowCanvas.getContext('2d');
            resizeArrowCanvas(); // Initial sizing
        }

        function resizeArrowCanvas() {
            if (!chessboardDiv || !arrowCanvas || !arrowCtx) return;
            // The canvas is inside chessboardWrapper which has the same dimensions as chessboardDiv
            arrowCanvas.width = chessboardWrapper.offsetWidth;
            arrowCanvas.height = chessboardWrapper.offsetHeight;
            drawCurrentArrows(); 
        }

        function getVisualSquareFromEvent(event) {
            const boardRect = chessboardDiv.getBoundingClientRect(); // Use chessboardDiv for relative coordinates
            const x = event.clientX - boardRect.left;
            const y = event.clientY - boardRect.top;
            
            const squareWidth = chessboardDiv.offsetWidth / BOARD_SIZE;
            const squareHeight = chessboardDiv.offsetHeight / BOARD_SIZE;

            const visualCol = Math.floor(x / squareWidth);
            const visualRow = Math.floor(y / squareHeight);

            if (visualRow >= 0 && visualRow < BOARD_SIZE && visualCol >= 0 && visualCol < BOARD_SIZE) {
                return { visualRow, visualCol };
            }
            return { visualRow: null, visualCol: null }; // Clicked outside a square
        }
        
        function drawArrowLineWithHead(fromVis, toVis, color, lineWidth = 3) {
            if (!arrowCtx || !arrowCanvas) return;
            const squareWidth = arrowCanvas.width / BOARD_SIZE;
            const squareHeight = arrowCanvas.height / BOARD_SIZE;

            const fromCX = (fromVis.visualCol + 0.5) * squareWidth;
            const fromCY = (fromVis.visualRow + 0.5) * squareHeight;
            const toCX = (toVis.visualCol + 0.5) * squareWidth;
            const toCY = (toVis.visualRow + 0.5) * squareHeight;

            arrowCtx.strokeStyle = color;
            arrowCtx.fillStyle = color;
            arrowCtx.lineWidth = lineWidth;

            // Line
            arrowCtx.beginPath();
            arrowCtx.moveTo(fromCX, fromCY);
            arrowCtx.lineTo(toCX, toCY);
            arrowCtx.stroke();

            // Arrowhead
            const angle = Math.atan2(toCY - fromCY, toCX - fromCX);
            const headLength = Math.min(squareWidth, squareHeight) * 0.20; // Arrowhead size
            const arrowAngle = Math.PI / 7; // Angle of arrowhead wings

            arrowCtx.beginPath();
            arrowCtx.moveTo(toCX, toCY);
            arrowCtx.lineTo(toCX - headLength * Math.cos(angle - arrowAngle), toCY - headLength * Math.sin(angle - arrowAngle));
            arrowCtx.lineTo(toCX - headLength * Math.cos(angle + arrowAngle), toCY - headLength * Math.sin(angle + arrowAngle));
            arrowCtx.closePath();
            arrowCtx.fill();
        }

        function drawCurrentArrows() {
            if (!arrowCtx || !arrowCanvas) return;
            arrowCtx.clearRect(0, 0, arrowCanvas.width, arrowCanvas.height);

            arrowsOnBoard.forEach(arrow => {
                const fromVisual = actualToVisualCoords(arrow.from.r, arrow.from.c);
                const toVisual = actualToVisualCoords(arrow.to.r, arrow.to.c);
                drawArrowLineWithHead(fromVisual, toVisual, arrow.color, 3);
            });

            // Draw preview arrow
            if (isDrawingArrow && arrowStartSquareVisual && currentMouseSquareVisual &&
                (arrowStartSquareVisual.visualRow !== currentMouseSquareVisual.visualRow || arrowStartSquareVisual.visualCol !== currentMouseSquareVisual.visualCol)) {
                drawArrowLineWithHead(arrowStartSquareVisual, currentMouseSquareVisual, 'rgba(50, 180, 50, 0.5)', 3); // Preview color
            }
        }

        function handleBoardContextMenu(event) {
            event.preventDefault(); // Prevent default context menu
        }

        function handleArrowMouseDown(event) {
            if (event.button === 2) { // Right mouse button
                event.preventDefault();
                const { visualRow, visualCol } = getVisualSquareFromEvent(event);
                if (visualRow !== null) { // Clicked on a square
                    isDrawingArrow = true;
                    arrowStartSquareVisual = { visualRow, visualCol };
                    currentMouseSquareVisual = { visualRow, visualCol }; // Initialize for click detection
                } else {
                    isDrawingArrow = false; // Clicked outside a square on the board padding
                    arrowStartSquareVisual = null;
                }
            }
        }

        function handleArrowMouseMove(event) {
            if (isDrawingArrow && arrowStartSquareVisual) {
                event.preventDefault();
                const { visualRow, visualCol } = getVisualSquareFromEvent(event);
                if (visualRow !== null) {
                    currentMouseSquareVisual = { visualRow, visualCol };
                } else {
                    currentMouseSquareVisual = null; // Mouse moved off board
                }
                drawCurrentArrows(); // Redraw with preview
            }
        }

        function handleArrowMouseUp(event) {
            if (event.button === 2) { // Right mouse button
                event.preventDefault();
                if (isDrawingArrow && arrowStartSquareVisual) {
                    const { visualRow: endVisualRow, visualCol: endVisualCol } = currentMouseSquareVisual || getVisualSquareFromEvent(event);

                    if (endVisualRow !== null && // Ended on a valid square (or was last valid square)
                        (arrowStartSquareVisual.visualRow !== endVisualRow || arrowStartSquareVisual.visualCol !== endVisualCol)) {
                        // Dragged to a *different* square
                        const { actualBoardRow: startActualR, actualBoardCol: startActualC } = visualToActualCoords(arrowStartSquareVisual.visualRow, arrowStartSquareVisual.visualCol);
                        const { actualBoardRow: endActualR, actualBoardCol: endActualC } = visualToActualCoords(endVisualRow, endVisualCol);
                        arrowsOnBoard.push({ 
                            from: { r: startActualR, c: startActualC }, 
                            to: { r: endActualR, c: endActualC }, 
                            color: 'rgba(20, 130, 20, 0.7)' // Standard green arrow
                        });
                    } else {
                        // Clicked on the same square, or dragged off board then released, or dragged very minimally
                        arrowsOnBoard = []; // Clear all arrows
                    }
                } else if (isDrawingArrow && !arrowStartSquareVisual) {
                    // This case: mousedown was on board padding, not a square.
                    // No arrow was started, so do nothing to arrowsOnBoard.
                } else if (!isDrawingArrow) {
                    // If isDrawingArrow is false, it means mousedown wasn't a right-click starting a drag
                    // or was outside a square. A simple right click without drag is handled by the above 'else'
                    // when arrowStartSquareVisual and endVisualRow/Col are the same.
                }

                isDrawingArrow = false;
                arrowStartSquareVisual = null;
                currentMouseSquareVisual = null;
                drawCurrentArrows(); // Final draw (either new arrow or cleared arrows)
            }
        }


        // --- Clock Management --- 
        function formatTime(totalSeconds) { 
            if (totalSeconds < 0) totalSeconds = 0;
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }
        function updateClockDisplays() { 
            clockWhiteDiv.textContent = formatTime(playerTimes.white);
            clockBlackDiv.textContent = formatTime(playerTimes.black);
           
            if (currentPlayer === 'white') {
                clockWhiteDiv.classList.add('active'); clockBlackDiv.classList.remove('active');
            } else {
                clockBlackDiv.classList.add('active'); clockWhiteDiv.classList.remove('active');
            }
            if (gameOver || gameTimeMode === 0 || currentMoveIndexInHistory !== moveHistory.length -1 && moveHistory.length > 0) { 
                 clockWhiteDiv.classList.remove('active'); clockBlackDiv.classList.remove('active');
            }
        }
        function stopClock() { 
            if (activeTimerId) { clearInterval(activeTimerId); activeTimerId = null; }
        }
        function startClock() { 
            stopClock(); 
            if (gameOver || gameTimeMode === 0 || (currentMoveIndexInHistory !== moveHistory.length -1 && moveHistory.length > 0) ) return;
            activeTimerId = setInterval(() => {
                playerTimes[currentPlayer]--;
                updateClockDisplays();
                if (playerTimes[currentPlayer] <= 0) {
                    stopClock(); gameOver = true;
                    const winner = currentPlayer === 'white' ? 'Black' : 'White';
                    showModalMessage(`Time's up! ${winner} wins.`);
                    updateStatus(`${winner} wins on time!`);
                    updateClockDisplays(); 
                }
            }, 1000);
        }
        function switchTurnsAndClocks() { 
            stopClock(); 
            updateClockDisplays(); 
            if (!gameOver && gameTimeMode > 0) { 
                startClock(); 
            }
        }
       
        // --- Material Score Calculation & Display --- 
        function calculateMaterialScore(currentBoard) {
            let whiteMaterial = 0;
            let blackMaterial = 0;
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const piece = currentBoard[r][c];
                    if (piece) {
                        const value = MATERIAL_VALUES[piece.toLowerCase()] || 0;
                        if (getPieceColor(piece) === 'white') {
                            whiteMaterial += value;
                        } else {
                            blackMaterial += value;
                        }
                    }
                }
            }
            return whiteMaterial - blackMaterial; 
        }
        function updateMaterialScoreDisplay(currentBoard) {
            const score = calculateMaterialScore(currentBoard);
            if (playerScoreTopDiv) playerScoreTopDiv.textContent = ''; 
            if (playerScoreBottomDiv) playerScoreBottomDiv.textContent = '';

            if (score > 0) { 
                if (!boardFlipped) { 
                    if (playerScoreBottomDiv) playerScoreBottomDiv.textContent = `+${score}`;
                } else { 
                    if (playerScoreTopDiv) playerScoreTopDiv.textContent = `+${score}`;
                }
            } else if (score < 0) { 
                if (!boardFlipped) { 
                    if (playerScoreTopDiv) playerScoreTopDiv.textContent = `+${Math.abs(score)}`;
                } else { 
                    if (playerScoreBottomDiv) playerScoreBottomDiv.textContent = `+${Math.abs(score)}`;
                }
            }
        }

        // --- Player Info & Captured Pieces Display --- 
        function updatePlayerInfoAndCapturedDisplays() {
            const whitePlayerName = "Player 1 (White)";
            const blackPlayerName = "Player 2 (Black)";

            playerClockAreaTop.innerHTML = '';
            playerClockAreaBottom.innerHTML = '';

            if (!boardFlipped) { 
                playerNameBottomDiv.textContent = whitePlayerName;
                playerNameTopDiv.textContent = blackPlayerName;
                playerClockAreaBottom.appendChild(clockWhiteWrapper);
                playerClockAreaTop.appendChild(clockBlackWrapper);
                renderCapturedPiecesList(capturedForPlayerBottomDiv, capturedByWhite, 'captured-by-player-bottom'); 
                renderCapturedPiecesList(capturedForPlayerTopDiv, capturedByBlack, 'captured-by-player-top');    
            } else { 
                playerNameBottomDiv.textContent = blackPlayerName;
                playerNameTopDiv.textContent = whitePlayerName;
                playerClockAreaBottom.appendChild(clockBlackWrapper);
                playerClockAreaTop.appendChild(clockWhiteWrapper);
                renderCapturedPiecesList(capturedForPlayerBottomDiv, capturedByBlack, 'captured-by-player-bottom'); 
                renderCapturedPiecesList(capturedForPlayerTopDiv, capturedByWhite, 'captured-by-player-top');    
            }
            updateMaterialScoreDisplay(boardState); 
            updateClockDisplays(); 
        }
        function renderCapturedPiecesList(containerDiv, capturedArray, cssClassForFallback) {
            const label = `<span class='captured-pieces-label'>Captures:</span>`;
            containerDiv.innerHTML = label; 
            if (capturedArray.length === 0) {
                const noneText = document.createTextNode(' None');
                containerDiv.appendChild(noneText);
            } else {
                capturedArray.forEach(pieceKey => {
                    const img = document.createElement('img');
                    img.src = PIECE_IMAGE_URLS[pieceKey];
                    img.alt = PIECE_ALT_TEXT[pieceKey] || pieceKey;
                    img.classList.add('piece-image');
                    img.onerror = function() { 
                        this.outerHTML = `<span class="piece-char-fallback ${cssClassForFallback}">${PIECE_FALLBACK_TEXT[pieceKey] || '?'}</span>`; 
                    };
                    containerDiv.appendChild(img);
                });
            }
        }

        // --- Move History --- 
        function renderMoveHistory() {
            moveHistoryListUl.innerHTML = '';
            moveHistory.forEach((moveEntry, index) => {
                const li = document.createElement('li');
                // For the "Initial Position" entry, don't show a move number or prefix
                const isInitial = moveEntry.notation === "Initial Position" || moveEntry.notation === "Custom Setup" || moveEntry.notation === "Loaded FEN";
                const moveNumber = Math.floor(index / 2) + (isInitial ? 0 : 1); // Adjust for non-initial entries
                const prefix = !isInitial && (index % 2 === 0) ? `${moveNumber}. ` : ''; 
               
                li.textContent = `${prefix}${moveEntry.notation}`;
                li.dataset.moveIndex = index;
                if (index === currentMoveIndexInHistory) {
                    li.classList.add('current-history-view');
                }
                li.addEventListener('click', () => navigateToMoveInHistory(index));
                moveHistoryListUl.appendChild(li);
            });
            if (moveHistoryListUl.lastChild) { 
                 moveHistoryListUl.scrollTop = moveHistoryListUl.lastChild.offsetTop;
            }
            prevMoveBtn.disabled = currentMoveIndexInHistory <= 0; // Can't go before initial state
            nextMoveBtn.disabled = currentMoveIndexInHistory >= moveHistory.length - 1;
        }

        function navigateToMoveInHistory(index) {
            if (index < 0 || index >= moveHistory.length) return;

            currentMoveIndexInHistory = index;
            deselectSquare();
            clearLastMoveHighlights();

            // The state to load is the state *after* the move at 'index' has been made.
            const historicMove = moveHistory[index];

            // Manually restore the entire game state from the history object.
            boardState = JSON.parse(JSON.stringify(historicMove.boardAfterMove));

            // Determine the current player based on the restored state.
            if (historicMove.notation === "Initial Position" || historicMove.notation === "Custom Setup" || historicMove.notation === "Loaded FEN") {
                // For the initial state, get the player from the FEN string.
                const parts = historicMove.fenBeforeMove.split(" ");
                currentPlayer = (parts[1] === 'w') ? 'white' : 'black';
            } else {
                // For subsequent moves, the next player is the opponent of the player who made the move.
                currentPlayer = historicMove.player === 'white' ? 'black' : 'white';
            }

            castlingRights = JSON.parse(JSON.stringify(historicMove.castlingRightsAfterMove));
            enPassantTargetSquare = historicMove.enPassantTargetAfterMove ? JSON.parse(JSON.stringify(historicMove.enPassantTargetAfterMove)) : null;
            halfmoveClock = historicMove.halfmoveClockAfterMove;
            fullmoveNumber = historicMove.fullmoveNumberAfterMove;

            if (historicMove.from && historicMove.to) {
                lastMove = { from: historicMove.from, to: historicMove.to };
            } else {
                lastMove = null; // For initial position
            }

            capturedByWhite = JSON.parse(JSON.stringify(historicMove.capturedByWhiteAfterMove || []));
            capturedByBlack = JSON.parse(JSON.stringify(historicMove.capturedByBlackAfterMove || []));

            // Now render everything based on this restored state
            createBoardUI(); // This will call renderPieces() and highlightLastMoveOnBoard() internally.
            renderMoveHistory();
            updatePlayerInfoAndCapturedDisplays();
            updateClockDisplays();
            
            // Update status message and clock
            if (currentMoveIndexInHistory === moveHistory.length - 1 && !gameOver) {
                statusMessageDiv.textContent = `${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}'s turn.`;
                if (gameTimeMode > 0) startClock();
                checkAIPlay();
            } else {
                statusMessageDiv.textContent = `Viewing after: ${historicMove.notation}`;
                stopClock();
            }
            
            arrowsOnBoard = [];
            drawCurrentArrows();
        }


        // --- Backend Simulation & AI Call --- 
        function fetchInitialBoardStateInternal() { 
             return [
                ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], 
                [null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null], 
                [null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null], 
                ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'], ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']  
            ];
        }
        async function fetchInitialBoardState() { 
            return fetchInitialBoardStateInternal();
        }

        async function fetchAIMoveFromPythonBackend(currentBoardState, aiColor) {
            if (aiIsThinking) return null; 
            aiIsThinking = true;
            updateStatus(`${aiColor.charAt(0).toUpperCase() + aiColor.slice(1)} (AI) is thinking...`);
            chessboardDiv.style.pointerEvents = 'none'; 

            let castleFenPart = "";
            if (castlingRights.K) castleFenPart += 'K';
            if (castlingRights.Q) castleFenPart += 'Q';
            if (castlingRights.k) castleFenPart += 'k';
            if (castlingRights.q) castleFenPart += 'q';
            if (castleFenPart === "") castleFenPart = "-";

            let epAlg = "-";
            if (enPassantTargetSquare) {
                epAlg = getAlgebraic(enPassantTargetSquare.row, enPassantTargetSquare.col);
            }

            // Prepare FEN history: Send FENs *before* each move, up to the current state.
            const fenHistoryForBackend = moveHistory
                .slice(0, currentMoveIndexInHistory + 1) 
                .map(entry => entry.fenBeforeMove);

            try {
                const response = await fetch(`${PYTHON_API_URL}/get-ai-move`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', },
                    body: JSON.stringify({
                        board_state: currentBoardState, 
                        player_color: aiColor,
                        en_passant_target: epAlg, 
                        castling_rights: castleFenPart, 
                        halfmove_clock: halfmoveClock,
                        fullmove_number: fullmoveNumber,
                        fen_history: fenHistoryForBackend 
                    }),
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('AI Server Error:', errorData.error || response.statusText);
                    showModalMessage(`AI Error: ${errorData.error || response.statusText}`);
                    return null;
                }
                const aiMove = await response.json();
                if (aiMove.error) {
                     showModalMessage(`AI Error: ${aiMove.error}`);
                     return null;
                }
                if (aiMove.message && !aiMove.fromSq) { 
                    // Handle messages like "AI is Checkmated" or "Draw by Threefold"
                    showModalMessage(aiMove.message); 
                    // Potentially update game state if message indicates game over
                    if (aiMove.message.toLowerCase().includes("checkmated") || aiMove.message.toLowerCase().includes("stalemated") || aiMove.message.toLowerCase().includes("draw")) {
                        gameOver = true;
                        stopClock();
                        updateStatus(aiMove.message);
                    }
                    return null; 
                }
                return aiMove; 
            } catch (error) {
                console.error('Network error fetching AI move:', error);
                showModalMessage('Network error: Could not connect to AI. Is the Python server running?');
                return null;
            } finally {
                aiIsThinking = false;
                chessboardDiv.style.pointerEvents = 'auto'; 
            }
        }


        async function sendMoveToBackend(fromSq, toSq, promotionPiece = null, isCastling = null, isEnPassant = false) {
            const piece = boardState[fromSq.actualBoardRow][fromSq.actualBoardCol]; 
            const pieceColor = getPieceColor(piece); 
            let capturedPieceKey = boardState[toSq.actualBoardRow][toSq.actualBoardCol]; 
            let enPassantCaptureOccurred = false;

            const newBoard = boardState.map(row => [...row]);
           
            newBoard[toSq.actualBoardRow][toSq.actualBoardCol] = piece; 
            newBoard[fromSq.actualBoardRow][fromSq.actualBoardCol] = null; 
           
            let message = `${PIECE_ALT_TEXT[piece]} ${getAlgebraic(fromSq.actualBoardRow, fromSq.actualBoardCol)}-${getAlgebraic(toSq.actualBoardRow, toSq.actualBoardCol)}.`;

            if (isEnPassant) {
                const capturedPawnRow = fromSq.actualBoardRow; 
                const capturedPawnCol = toSq.actualBoardCol;    
                capturedPieceKey = newBoard[capturedPawnRow][capturedPawnCol]; 
                newBoard[capturedPawnRow][capturedPawnCol] = null; 
                enPassantCaptureOccurred = true;
                message = `${PIECE_ALT_TEXT[piece]} ${getAlgebraic(fromSq.actualBoardRow, fromSq.actualBoardCol)}x${getAlgebraic(toSq.actualBoardRow, toSq.actualBoardCol)} e.p.`;
            } else if (isCastling) {
                if (isCastling === 'kingSide') { 
                    const rookOriginalCol = 7; const rookNewCol = 5;
                    newBoard[fromSq.actualBoardRow][rookNewCol] = newBoard[fromSq.actualBoardRow][rookOriginalCol];
                    newBoard[fromSq.actualBoardRow][rookOriginalCol] = null;
                    message = "O-O";
                } else if (isCastling === 'queenSide') { 
                    const rookOriginalCol = 0; const rookNewCol = 3;
                    newBoard[fromSq.actualBoardRow][rookNewCol] = newBoard[fromSq.actualBoardRow][rookOriginalCol];
                    newBoard[fromSq.actualBoardRow][rookOriginalCol] = null;
                    message = "O-O-O";
                }
                capturedPieceKey = null; 
            }

            let promotionOccurred = false;
            if (!isCastling && !isEnPassant && (piece === 'P' && toSq.actualBoardRow === 0) || (piece === 'p' && toSq.actualBoardRow === 7)) {
                newBoard[toSq.actualBoardRow][toSq.actualBoardCol] = promotionPiece || (piece === 'P' ? 'Q' : 'q');
                promotionOccurred = true;
                 message = `${PIECE_ALT_TEXT[piece]} ${getAlgebraic(fromSq.actualBoardRow, fromSq.actualBoardCol)}-${getAlgebraic(toSq.actualBoardRow, toSq.actualBoardCol)}=${PIECE_ALT_TEXT[newBoard[toSq.actualBoardRow][toSq.actualBoardCol]]}`;
            }
           
            if (capturedPieceKey && !isCastling && !promotionOccurred && !enPassantCaptureOccurred) { 
                message = `${PIECE_ALT_TEXT[piece]} ${getAlgebraic(fromSq.actualBoardRow, fromSq.actualBoardCol)}x${getAlgebraic(toSq.actualBoardRow, toSq.actualBoardCol)}.`;
            }
           
            const nextPlayerTurn = (pieceColor === 'white') ? 'black' : 'white';
           
            const opponentKingPos = findKing(newBoard, nextPlayerTurn);
            let isOpponentInCheck = false;
            if (opponentKingPos) {
                isOpponentInCheck = isSquareAttacked(newBoard, opponentKingPos.row, opponentKingPos.col, pieceColor);
            }
           
            return { 
                isValid: true, newBoardState: newBoard, message: message, nextPlayer: nextPlayerTurn,
                capturedPieceKey: capturedPieceKey, 
                check: isOpponentInCheck, 
                checkmate: false, stalemate: false, 
                moveFrom: { row: fromSq.actualBoardRow, col: fromSq.actualBoardCol }, 
                moveTo: { row: toSq.actualBoardRow, col: toSq.actualBoardCol }    
            };
        }
       

        // --- Move Generation Logic ---
        function getPieceColor(pieceKey) { return pieceKey ? (pieceKey === pieceKey.toUpperCase() ? 'white' : 'black') : null; }
        function isOnBoard(r, c) { return r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE; }

        function findKing(board, color) {
            const kingKey = color === 'white' ? 'K' : 'k';
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] === kingKey) {
                        return { row: r, col: c };
                    }
                }
            }
            return null; 
        }

        function isSquareAttacked(board, targetRow, targetCol, attackerColor) {
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const pieceKey = board[r][c];
                    if (pieceKey && getPieceColor(pieceKey) === attackerColor) {
                        const pieceType = PIECE_FALLBACK_TEXT[pieceKey].toLowerCase();
                        const pseudoMoves = []; 
                       
                        if (pieceType === 'p') {
                            const dir = attackerColor === 'white' ? -1 : 1;
                            if (isOnBoard(r + dir, c - 1)) pseudoMoves.push({row: r + dir, col: c - 1});
                            if (isOnBoard(r + dir, c + 1)) pseudoMoves.push({row: r + dir, col: c + 1});
                        } else if (pieceType === 'n') {
                            [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]].forEach(m => {
                                if(isOnBoard(r+m[0], c+m[1])) pseudoMoves.push({row: r+m[0], col: c+m[1]});
                            });
                        } else if (pieceType === 'k') {
                             [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]].forEach(m => {
                                if(isOnBoard(r+m[0], c+m[1])) pseudoMoves.push({row: r+m[0], col: c+m[1]});
                            });
                        } else { 
                            let directions = [];
                            if (pieceType === 'r' || pieceType === 'q') directions.push(...[[0,1],[0,-1],[1,0],[-1,0]]);
                            if (pieceType === 'b' || pieceType === 'q') directions.push(...[[1,1],[1,-1],[-1,1],[-1,-1]]);
                            directions.forEach(dir => {
                                for (let i = 1; i < BOARD_SIZE; i++) {
                                    const tr = r + dir[0] * i; const tc = c + dir[1] * i;
                                    if (!isOnBoard(tr,tc)) break;
                                    pseudoMoves.push({row: tr, col: tc}); 
                                    if (board[tr][tc] !== null) break; 
                                }
                            });
                        }
                        for (const move of pseudoMoves) {
                            if (move.row === targetRow && move.col === targetCol) { return true; }
                        }
                    }
                }
            }
            return false; 
        }
       
        function hasAnyLegalMoves(board, playerColor) {
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const pieceKey = board[r][c];
                    if (pieceKey && getPieceColor(pieceKey) === playerColor) {
                        const moves = generateMoves(board, r, c); 
                        if (moves.length > 0) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }


        function generateMoves(board, pieceActualRow, pieceActualCol) { 
            const pseudoLegalMoves = []; 
            const pieceKey = board[pieceActualRow][pieceActualCol]; 
            if (!pieceKey) return pseudoLegalMoves;
            const pieceColor = getPieceColor(pieceKey); 
            const pieceType = PIECE_FALLBACK_TEXT[pieceKey].toLowerCase(); 

            function addPseudoMove(r, c, moveData = {}) { 
                if (isOnBoard(r, c)) {
                    const targetPieceKey = board[r][c];
                    if (targetPieceKey === null) { 
                        pseudoLegalMoves.push({ row: r, col: c, type: 'move', ...moveData }); return true; 
                    } else if (getPieceColor(targetPieceKey) !== pieceColor) { 
                        pseudoLegalMoves.push({ row: r, col: c, type: 'capture', ...moveData }); return false; 
                    }
                } return false; 
            }

            if (pieceType === 'p') { 
                const dir = pieceColor === 'white' ? -1 : 1; 
                const startRow = pieceColor === 'white' ? 6 : 1; 
               
                const enPassantVulnerableRank = pieceColor === 'white' ? 3 : 4; 

                if (isOnBoard(pieceActualRow + dir, pieceActualCol) && board[pieceActualRow + dir][pieceActualCol] === null) {
                    addPseudoMove(pieceActualRow + dir, pieceActualCol);
                    if (pieceActualRow === startRow && isOnBoard(pieceActualRow + 2 * dir, pieceActualCol) && board[pieceActualRow + 2 * dir][pieceActualCol] === null) { 
                        addPseudoMove(pieceActualRow + 2 * dir, pieceActualCol, { isTwoStepPawnMove: true }); 
                    }
                }
                [-1, 1].forEach(colOffset => { 
                    if (isOnBoard(pieceActualRow+dir,pieceActualCol+colOffset)) { 
                        const targetKey = board[pieceActualRow+dir][pieceActualCol+colOffset]; 
                        if(targetKey!==null&&getPieceColor(targetKey)!==pieceColor) 
                            addPseudoMove(pieceActualRow+dir,pieceActualCol+colOffset);
                    }
                });
                if (enPassantTargetSquare && enPassantTargetSquare.row === pieceActualRow + dir) {
                     if (Math.abs(pieceActualCol - enPassantTargetSquare.col) === 1) { 
                        const attackingPawnRankForEP = pieceColor === 'white' ? 3 : 4; 
                        if (pieceActualRow === attackingPawnRankForEP) {
                             addPseudoMove(enPassantTargetSquare.row, enPassantTargetSquare.col, { type: 'enpassant' });
                        }
                    }
                }
            }
            if (pieceType === 'n') { 
                [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]].forEach(m => addPseudoMove(pieceActualRow+m[0],pieceActualCol+m[1]));
            }
            function addSlidingMoves(directions) { 
                directions.forEach(dir => { 
                    for(let i=1;i<BOARD_SIZE;i++) { 
                        if(!addPseudoMove(pieceActualRow+dir[0]*i,pieceActualCol+dir[1]*i)) break; 
                    }
                });
            }
            if (pieceType === 'r' || pieceType === 'q') { addSlidingMoves([[0,1],[0,-1],[1,0],[-1,0]]); }
            if (pieceType === 'b' || pieceType === 'q') { addSlidingMoves([[1,1],[1,-1],[-1,1],[-1,-1]]); }
           
            if (pieceType === 'k') { 
                [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]].forEach(m=>addPseudoMove(pieceActualRow+m[0],pieceActualCol+m[1]));
               
                const kingRow = pieceColor === 'white' ? 7 : 0; 
                const opponentColor = pieceColor === 'white' ? 'black' : 'white';

                if (pieceActualRow === kingRow && pieceActualCol === 4 && !isSquareAttacked(board, kingRow, 4, opponentColor)) {
                    if ( (pieceColor === 'white' && castlingRights.K) || (pieceColor === 'black' && castlingRights.k) ) {
                        if (board[kingRow][5] === null && board[kingRow][6] === null &&
                            !isSquareAttacked(board, kingRow, 5, opponentColor) &&
                            !isSquareAttacked(board, kingRow, 6, opponentColor)) {
                            addPseudoMove(kingRow, 6, { castling: 'kingSide' });
                        }
                    }
                    if ( (pieceColor === 'white' && castlingRights.Q) || (pieceColor === 'black' && castlingRights.q) ) {
                        if (board[kingRow][3] === null && board[kingRow][2] === null && board[kingRow][1] === null &&
                            !isSquareAttacked(board, kingRow, 3, opponentColor) &&
                            !isSquareAttacked(board, kingRow, 2, opponentColor)) {
                            addPseudoMove(kingRow, 2, { castling: 'queenSide' });
                        }
                    }
                }
            }
           
            const legalMoves = pseudoLegalMoves.filter(move => {
                const tempBoard = board.map(r => [...r]);
                const movedPiece = tempBoard[pieceActualRow][pieceActualCol]; 
                tempBoard[move.row][move.col] = movedPiece;
                tempBoard[pieceActualRow][pieceActualCol] = null;

                if (move.castling) {
                    const rRow = pieceActualRow;
                    if (move.castling === 'kingSide') {
                        tempBoard[rRow][5] = tempBoard[rRow][7]; tempBoard[rRow][7] = null;
                    } else { 
                        tempBoard[rRow][3] = tempBoard[rRow][0]; tempBoard[rRow][0] = null;
                    }
                } else if (move.type === 'enpassant') {
                    const capturedPawnActualRow = pieceColor === 'white' ? move.row + 1 : move.row -1;
                    tempBoard[capturedPawnActualRow][move.col] = null;
                }

                const kingPos = findKing(tempBoard, pieceColor);
                if (!kingPos) return false; 
                return !isSquareAttacked(tempBoard, kingPos.row, kingPos.col, (pieceColor === 'white' ? 'black' : 'white'));
            });
            return legalMoves; 
        }

        // --- Coordinate Transformation --- 
        function visualToActualCoords(visualRow, visualCol) {
            if (boardFlipped) { return { actualBoardRow: BOARD_SIZE - 1 - visualRow, actualBoardCol: BOARD_SIZE - 1 - visualCol }; }
            return { actualBoardRow: visualRow, actualBoardCol: visualCol };
        }
        function actualToVisualCoords(actualBoardRow, actualBoardCol) {
            if (boardFlipped) { return { visualRow: BOARD_SIZE - 1 - actualBoardRow, visualCol: BOARD_SIZE - 1 - actualBoardCol }; }
            return { visualRow: actualBoardRow, visualCol: actualBoardCol };
        }

        // --- UI Rendering and Interaction --- 
        function clearLastMoveHighlights() {
            document.querySelectorAll('.square.last-move-from, .square.last-move-to').forEach(sq => {
                sq.classList.remove('last-move-from', 'last-move-to');
            });
        }
        function highlightLastMoveOnBoard() {
            clearLastMoveHighlights();
            if (lastMove) {
                const fromVisual = actualToVisualCoords(lastMove.from.row, lastMove.from.col);
                const toVisual = actualToVisualCoords(lastMove.to.row, lastMove.to.col);
                const fromSqDiv = chessboardDiv.querySelector(`.square[data-visual-row='${fromVisual.visualRow}'][data-visual-col='${fromVisual.visualCol}']`);
                const toSqDiv = chessboardDiv.querySelector(`.square[data-visual-row='${toVisual.visualRow}'][data-visual-col='${toVisual.visualCol}']`);
                if (fromSqDiv) fromSqDiv.classList.add('last-move-from');
                if (toSqDiv) toSqDiv.classList.add('last-move-to');
            }
        }
        function createBoardUI() {  
            chessboardDiv.innerHTML = ''; 
            const rlL = document.querySelector('.rank-labels-left'); const rlR = document.querySelector('.rank-labels-right');
            const flT = document.querySelector('.file-labels-top'); const flB = document.querySelector('.file-labels-bottom'); 
            rlL.innerHTML = ''; rlR.innerHTML = ''; flT.innerHTML = ''; flB.innerHTML = ''; 
            for(let vr=0; vr<BOARD_SIZE; vr++) { 
                let rfd; if (!boardFlipped) { rfd = BOARD_SIZE - vr; } else { rfd = vr + 1; }
                let rle = document.createElement('div'); rle.classList.add('rank-label'); rle.textContent = rfd;
                rlL.appendChild(rle.cloneNode(true)); rlR.appendChild(rle.cloneNode(true));
            }
            for(let vc=0; vc<BOARD_SIZE; vc++) { 
                let ffd; if (!boardFlipped) { ffd = String.fromCharCode('a'.charCodeAt(0) + vc); } else { ffd = String.fromCharCode('h'.charCodeAt(0) - vc); }
                let fle = document.createElement('div'); fle.classList.add('file-label'); fle.textContent = ffd;
                flT.appendChild(fle.cloneNode(true)); flB.appendChild(fle.cloneNode(true));
            }
            for(let vr=0; vr<BOARD_SIZE; vr++){ for(let vc=0; vc<BOARD_SIZE; vc++){ 
                const sq = document.createElement('div'); sq.classList.add('square');
                const { actualBoardRow, actualBoardCol } = visualToActualCoords(vr, vc);
                sq.classList.add((actualBoardRow + actualBoardCol) % 2 !== 0 ? 'dark' : 'light');
                sq.dataset.visualRow = vr; sq.dataset.visualCol = vc; 
                sq.addEventListener('click', onSquareClick);
                sq.addEventListener('dragover', handleDragOver);
                sq.addEventListener('drop', (event) => handleDrop(event, vr, vc));
                chessboardDiv.appendChild(sq); 
            }}
            renderPieces(); 
            highlightLastMoveOnBoard();
            resizeArrowCanvas(); // Ensure canvas is sized and arrows redrawn
        }
        function renderPieces() {  
            const sqs = chessboardDiv.children; 
            if (!sqs || sqs.length !== BOARD_SIZE * BOARD_SIZE) { return; }
            for(let vr=0; vr<BOARD_SIZE; vr++){ for(let vc=0; vc<BOARD_SIZE; vc++){ 
                const sD = sqs[vr * BOARD_SIZE + vc]; 
                while (sD.firstChild && !sD.firstChild.classList?.contains('rank-label') && !sD.firstChild.classList?.contains('file-label')) {
                    sD.removeChild(sD.firstChild);
                }
               
                const { actualBoardRow, actualBoardCol } = visualToActualCoords(vr, vc);
                if (boardState && Array.isArray(boardState[actualBoardRow])) { 
                    const pK = boardState[actualBoardRow][actualBoardCol]; 
                    if(pK && PIECE_IMAGE_URLS[pK]){
                        const img = document.createElement('img'); img.src = PIECE_IMAGE_URLS[pK];
                        img.alt = PIECE_ALT_TEXT[pK] || pK; img.classList.add('piece-image');
                        img.draggable = true; 
                        img.addEventListener('dragstart', (event) => handleDragStart(event, actualBoardRow, actualBoardCol, pK));
                        img.addEventListener('dragend', handleDragEnd);

                        img.onerror = function() { 
                            const pcc = getPieceColor(pK) === 'white' ? 'white' : 'black';
                            this.outerHTML = `<span class="piece-char-fallback-board ${pcc}">${PIECE_FALLBACK_TEXT[pK] || '?'}</span>`;
                        };
                        sD.appendChild(img);
                    }
                }
            }}
        }
        function highlightLegalMoves(moves) { 
            moves.forEach(m => {
                const { visualRow, visualCol } = actualToVisualCoords(m.row, m.col);
                const sD = chessboardDiv.querySelector(`.square[data-visual-row='${visualRow}'][data-visual-col='${visualCol}']`); 
                if(sD){ 
                    if (m.type ==='capture' || m.type ==='enpassant') {
                        sD.classList.add('highlight-capture-ring');
                    } else { 
                        sD.classList.add('highlight-move-dot');
                    }
                }
            });
        }
       
        // --- Drag and Drop Handlers --- 
        function handleDragStart(event, actualR, actualC, pieceKey) {
            if (isSetupMode) { 
                event.preventDefault();
                return;
            }
            if (getPieceColor(pieceKey) !== currentPlayer || (currentMoveIndexInHistory !== -1 && currentMoveIndexInHistory < moveHistory.length -1) || gameOver) {
                event.preventDefault();
                return;
            }
            draggedImageElement = event.target; 
            setTimeout(() => { 
                if (draggedImageElement) draggedImageElement.classList.add('lifted');
            }, 0);

            event.dataTransfer.setData("text/plain", JSON.stringify({ 
                fromActualR: actualR, 
                fromActualC: actualC, 
                pieceKey: pieceKey 
            }));
            event.dataTransfer.effectAllowed = "move";
           
            selectSquare(actualR, actualC, pieceKey); 
            generatedLegalMoves = generateMoves(boardState, actualR, actualC); 
            highlightLegalMoves(generatedLegalMoves);
        }

        function handleDragOver(event) {
            event.preventDefault(); 
            if (isSetupMode || (draggedImageElement || draggedPalettePiece)) { 
                 event.dataTransfer.dropEffect = "move";
            } else {
                 event.dataTransfer.dropEffect = "none";
            }
        }

        async function handleDrop(event, targetVisualR, targetVisualC) {
            event.preventDefault();
            const { actualBoardRow: targetActualR, actualBoardCol: targetActualC } = visualToActualCoords(targetVisualR, targetVisualC);

            if (isSetupMode) {
                if (draggedPalettePiece) {
                    boardState[targetActualR][targetActualC] = draggedPalettePiece;
                    draggedPalettePiece = null;
                    renderPieces(); 
                }
                return;
            }

            if (draggedImageElement) { 
                draggedImageElement.classList.remove('lifted');
            }

            if (gameOver || (currentMoveIndexInHistory !== -1 && currentMoveIndexInHistory < moveHistory.length -1)) {
                draggedImageElement = null;
                deselectSquare();
                return;
            }

            const draggedDataString = event.dataTransfer.getData("text/plain");
            if (!draggedDataString) {
                draggedImageElement = null;
                deselectSquare(); 
                return;
            }
            const draggedData = JSON.parse(draggedDataString);


            const moveDetails = generatedLegalMoves.find(m => m.row === targetActualR && m.col === targetActualC);

            if (moveDetails) {
                let promotionChoiceKey = null;
                const pieceToMoveKey = draggedData.pieceKey; 
                if ((pieceToMoveKey === 'P' && targetActualR === 0) || (pieceToMoveKey === 'p' && targetActualR === 7)) {
                    let rawPromotionChoice = prompt("Promote pawn to (Q, R, B, N)?", "Q");
                    if (rawPromotionChoice) { rawPromotionChoice = rawPromotionChoice.toUpperCase();
                        if (['Q','R','B','N'].includes(rawPromotionChoice)) { promotionChoiceKey = pieceToMoveKey==='P'?rawPromotionChoice:rawPromotionChoice.toLowerCase();}
                        else { promotionChoiceKey = (pieceToMoveKey==='P'?'Q':'q');}
                    } else { promotionChoiceKey = (pieceToMoveKey==='P'?'Q':'q');} 
                }

                const moveResult = await sendMoveToBackend(
                    { actualBoardRow: draggedData.fromActualR, actualBoardCol: draggedData.fromActualC },
                    { actualBoardRow: targetActualR, actualBoardCol: targetActualC },
                    promotionChoiceKey,
                    moveDetails.castling,
                    moveDetails.type === 'enpassant'
                );
                await processMoveResult(moveResult); 
            } else {
                deselectSquare(); 
            }
            draggedImageElement = null; 
        }
       
        function handleDragEnd(event) {
            if (isSetupMode) { 
                draggedPalettePiece = null;
                return;
            }
            if (draggedImageElement) {
                draggedImageElement.classList.remove('lifted'); 
                draggedImageElement = null;
            }
            if (selectedSquare) {
                 deselectSquare();
            }
        }


        async function onSquareClick(event) { 
            if (isSetupMode) {
                const clickedSquareDiv = event.currentTarget;
                const visualRow = parseInt(clickedSquareDiv.dataset.visualRow);
                const visualCol = parseInt(clickedSquareDiv.dataset.visualCol);
                const { actualBoardRow, actualBoardCol } = visualToActualCoords(visualRow, visualCol);
               
                if (boardState[actualBoardRow][actualBoardCol]) { 
                    boardState[actualBoardRow][actualBoardCol] = null;
                    renderPieces();
                }
                return;
            }


            if (gameOver || (currentMoveIndexInHistory !== -1 && currentMoveIndexInHistory < moveHistory.length -1) ) { 
                if (gameOver) showModalMessage("Game is over. Start a new game.");
                else showModalMessage("Navigated to past move. Click 'Next' to return to live game or start a new game.");
                return; 
            } 
            const clickedSquareDiv = event.currentTarget; 
            const visualRow = parseInt(clickedSquareDiv.dataset.visualRow); 
            const visualCol = parseInt(clickedSquareDiv.dataset.visualCol); 
            const { actualBoardRow, actualBoardCol } = visualToActualCoords(visualRow, visualCol);

            if (selectedSquare) { 
                const moveDetails = generatedLegalMoves.find(m => m.row === actualBoardRow && m.col === actualBoardCol);
                if (moveDetails) { 
                    let promotionChoiceKey = null; 
                    const pieceToMoveKey = selectedSquare.pieceKey;
                    if ((pieceToMoveKey === 'P' && actualBoardRow === 0) || (pieceToMoveKey === 'p' && actualBoardRow === 7)) {
                        let rawPromotionChoice = prompt("Promote pawn to (Q, R, B, N)?", "Q");
                        if (rawPromotionChoice) { rawPromotionChoice = rawPromotionChoice.toUpperCase();
                            if (['Q','R','B','N'].includes(rawPromotionChoice)) { promotionChoiceKey = pieceToMoveKey==='P'?rawPromotionChoice:rawPromotionChoice.toLowerCase();}
                            else { promotionChoiceKey = (pieceToMoveKey==='P'?'Q':'q');}
                        } else { promotionChoiceKey = (pieceToMoveKey==='P'?'Q':'q');}
                    }
                    const moveResult = await sendMoveToBackend(
                        { actualBoardRow: selectedSquare.actualBoardRow, actualBoardCol: selectedSquare.actualBoardCol }, 
                        { actualBoardRow, actualBoardCol }, 
                        promotionChoiceKey,
                        moveDetails.castling,
                        moveDetails.type === 'enpassant' 
                    );
                    await processMoveResult(moveResult); 
                } else if (selectedSquare.actualBoardRow === actualBoardRow && selectedSquare.actualBoardCol === actualBoardCol) { 
                    deselectSquare(); 
                } else { 
                    const clickedPieceKeyOnBoard = boardState[actualBoardRow][actualBoardCol];
                    if (clickedPieceKeyOnBoard && getPieceColor(clickedPieceKeyOnBoard) === currentPlayer) { 
                        deselectSquare(); 
                        selectSquare(actualBoardRow, actualBoardCol, clickedPieceKeyOnBoard); 
                        generatedLegalMoves = generateMoves(boardState, actualBoardRow, actualBoardCol); 
                        highlightLegalMoves(generatedLegalMoves);
                    } else { 
                        deselectSquare(); 
                    }
                }
            } else { 
                const pieceKeyOnBoard = boardState[actualBoardRow][actualBoardCol];
                if (pieceKeyOnBoard) {
                    if (getPieceColor(pieceKeyOnBoard) === currentPlayer) { 
                        selectSquare(actualBoardRow, actualBoardCol, pieceKeyOnBoard);
                        generatedLegalMoves = generateMoves(boardState, actualBoardRow, actualBoardCol); 
                        highlightLegalMoves(generatedLegalMoves);
                    }
                }
            }
        }
       
        async function processMoveResult(result, isAIMove = false) { 
            let localEnPassantTargetSquareForNextTurn = null; 

            if (result.isValid) {
                const fenBeforeMove = generateFENInternal(); 
                const movedPieceKeyBeforeMove = boardState[result.moveFrom.row][result.moveFrom.col]; 
               
                if (movedPieceKeyBeforeMove && movedPieceKeyBeforeMove.toLowerCase() === 'p') {
                    if (Math.abs(result.moveFrom.row - result.moveTo.row) === 2) {
                        localEnPassantTargetSquareForNextTurn = {
                            row: (result.moveFrom.row + result.moveTo.row) / 2, 
                            col: result.moveFrom.col
                        };
                    }
                }
               
                const castlingRightsBeforeMove = JSON.parse(JSON.stringify(castlingRights));

                boardState = result.newBoardState; 
                lastMove = { from: result.moveFrom, to: result.moveTo }; 
                enPassantTargetSquare = localEnPassantTargetSquareForNextTurn; 
               
                const fromRow = result.moveFrom.row;
                const fromCol = result.moveFrom.col;
                const toRow = result.moveTo.row;
                const toCol = result.moveTo.col;
                const movedPieceAfterMove = boardState[toRow][toCol]; 

                if (movedPieceAfterMove === 'K') { castlingRights.K = castlingRights.Q = false; }
                if (movedPieceAfterMove === 'k') { castlingRights.k = castlingRights.q = false; }
                if (fromRow === 7 && fromCol === 0) { castlingRights.Q = false; } 
                if (fromRow === 7 && fromCol === 7) { castlingRights.K = false; } 
                if (fromRow === 0 && fromCol === 0) { castlingRights.q = false; } 
                if (fromRow === 0 && fromCol === 7) { castlingRights.k = false; } 
                if (toRow === 7 && toCol === 0 && result.capturedPieceKey === 'R') castlingRights.Q = false;
                if (toRow === 7 && toCol === 7 && result.capturedPieceKey === 'R') castlingRights.K = false;
                if (toRow === 0 && toCol === 0 && result.capturedPieceKey === 'r') castlingRights.q = false;
                if (toRow === 0 && toCol === 7 && result.capturedPieceKey === 'r') castlingRights.k = false;


                if (movedPieceKeyBeforeMove && (movedPieceKeyBeforeMove.toLowerCase() === 'p') || result.capturedPieceKey) {
                    halfmoveClock = 0;
                } else {
                    halfmoveClock++;
                }
                if (currentPlayer === 'black') { 
                    fullmoveNumber++;
                }
               
                if (result.capturedPieceKey) {
                    const capturedColor = getPieceColor(result.capturedPieceKey);
                    if (capturedColor === 'black') { capturedByWhite.push(result.capturedPieceKey); } 
                    else if (capturedColor === 'white') { capturedByBlack.push(result.capturedPieceKey); }
                }

                // Truncate moveHistory and positionHistoryForRepetition if we are branching from a previous state
                if (currentMoveIndexInHistory < moveHistory.length - 1) {
                    moveHistory = moveHistory.slice(0, currentMoveIndexInHistory + 1);
                    if (positionHistoryForRepetition.length > currentMoveIndexInHistory + 1) {
                         positionHistoryForRepetition = positionHistoryForRepetition.slice(0, currentMoveIndexInHistory + 1);
                    }
                }


                moveHistory.push({
                    notation: result.message, 
                    fenBeforeMove: fenBeforeMove, 
                    boardAfterMove: JSON.parse(JSON.stringify(boardState)), 
                    from: result.moveFrom, to: result.moveTo, player: currentPlayer,
                    capturedPiece: result.capturedPieceKey, 
                    castlingRightsBeforeMove: castlingRightsBeforeMove, 
                    castlingRightsAfterMove: JSON.parse(JSON.stringify(castlingRights)), 
                    capturedByWhiteAfterMove: JSON.parse(JSON.stringify(capturedByWhite)), 
                    capturedByBlackAfterMove: JSON.parse(JSON.stringify(capturedByBlack)),
                    enPassantTargetBeforeMove: enPassantTargetSquare ? JSON.parse(JSON.stringify(enPassantTargetSquare)) : null, 
                    enPassantTargetAfterMove: localEnPassantTargetSquareForNextTurn ? JSON.parse(JSON.stringify(localEnPassantTargetSquareForNextTurn)) : null, 
                    halfmoveClockAfterMove: halfmoveClock, 
                    fullmoveNumberAfterMove: fullmoveNumber 
                });
                currentMoveIndexInHistory = moveHistory.length - 1; 

                const simplifiedFenAfterMove = generateSimplifiedFENForRepetition(boardState, result.nextPlayer, castlingRights, enPassantTargetSquare);
                positionHistoryForRepetition.push(simplifiedFenAfterMove);


                renderPieces(); 
                highlightLastMoveOnBoard(); 
                renderMoveHistory(); 
                updatePlayerInfoAndCapturedDisplays();

                const previousPlayer = currentPlayer; 
                deselectSquare(); 
                currentPlayer = result.nextPlayer; 
                updateStatus(result.message + (result.check ? " Check!" : "")); 
                
                // --- MODIFICATION: Clear arrows after a move is processed ---
                arrowsOnBoard = []; 
                drawCurrentArrows(); 
                // --- End of MODIFICATION ---
               
                if (checkForThreefoldRepetition()) {
                    showModalMessage("Draw by Threefold Repetition!");
                    updateStatus("Draw by Threefold Repetition!");
                    gameOver = true;
                    stopClock();
                    updateClockDisplays(); 
                    return; 
                }

                if (result.check) { 
                    if (!hasAnyLegalMoves(boardState, currentPlayer)) {
                        showModalMessage(`Checkmate! ${previousPlayer.charAt(0).toUpperCase() + previousPlayer.slice(1)} wins.`); 
                        gameOver = true; stopClock();
                    }
                } else { 
                     if (!hasAnyLegalMoves(boardState, currentPlayer)) {
                        showModalMessage("Stalemate! It's a draw.");
                        gameOver = true; stopClock();
                    }
                }
               
                if (!gameOver) { 
                    switchTurnsAndClocks(); 
                    checkAIPlay(); 
                } else { 
                    updateClockDisplays(); 
                } 
            } else { 
                deselectSquare(); 
            }
            // Redraw arrows in case of an invalid move attempt (though usually they'd be cleared by deselectSquare or a new valid move)
            // However, the primary clearing is now done inside the `if (result.isValid)` block.
            // drawCurrentArrows(); // This might be redundant if deselectSquare clears them, but safe.
        }

        function selectSquare(actualBoardRow, actualBoardCol, pieceKey) { 
            deselectSquare(); 
            selectedSquare = { actualBoardRow, actualBoardCol, pieceKey: pieceKey }; 
            const { visualRow, visualCol } = actualToVisualCoords(actualBoardRow, actualBoardCol);
            const squareDiv = chessboardDiv.querySelector(`.square[data-visual-row='${visualRow}'][data-visual-col='${visualCol}']`);
            if (squareDiv) squareDiv.classList.add('selected');
        }
        function deselectSquare() { 
            if(selectedSquare){
                const { visualRow, visualCol } = actualToVisualCoords(selectedSquare.actualBoardRow, selectedSquare.actualBoardCol);
                const prevSelectedDiv = chessboardDiv.querySelector(`.square[data-visual-row='${visualRow}'][data-visual-col='${visualCol}']`);
                if(prevSelectedDiv){ prevSelectedDiv.classList.remove('selected'); }
            }
            selectedSquare=null; generatedLegalMoves=[];
            document.querySelectorAll('.square.highlight-move-dot, .square.highlight-capture-ring').forEach(sq=>{ 
                sq.classList.remove('highlight-move-dot', 'highlight-capture-ring');
            });
        }
        function updateStatus(message) { statusMessageDiv.textContent = message; }
        function getAlgebraic(actualBoardRow, actualBoardCol) {
            const fileChar = String.fromCharCode('a'.charCodeAt(0) + actualBoardCol);
            const rankNum = BOARD_SIZE - actualBoardRow;
            return `${fileChar}${rankNum}`;
        }
        function fromAlgebraic(alg) {
            if (!alg || alg.length !== 2) return null;
            const file = alg.charCodeAt(0) - 'a'.charCodeAt(0);
            const rank = BOARD_SIZE - parseInt(alg[1]); // FEN rank to 0-indexed board row
            if (file < 0 || file >= BOARD_SIZE || rank < 0 || rank >= BOARD_SIZE) return null;
            return { row: rank, col: file };
        }
        function showModalMessage(text) { modalMessageText.textContent = text; messageModal.style.display = 'flex'; }
        function hideModal() { messageModal.style.display = 'none'; }
       
        async function initializeGame(fen = START_FEN) {
            stopClock(); 
            const selectedTimeValue = document.querySelector('input[name="timeControl"]:checked').value;
            gameTimeMode = parseInt(selectedTimeValue);

            gameOver = false; 
            lastMove = null; 
           
            capturedByWhite = []; 
            capturedByBlack = []; 
            moveHistory = []; 
            positionHistoryForRepetition = []; 
            currentMoveIndexInHistory = -1; 
            arrowsOnBoard = []; // Clear arrows for new game
           
            if (!parseFEN(fen)) { 
                console.error("Failed to parse FEN in initializeGame. Reverting to default.");
                parseFEN(START_FEN); 
            }
           
            const initialSimplifiedFen = generateSimplifiedFENForRepetition(boardState, currentPlayer, castlingRights, enPassantTargetSquare);
            positionHistoryForRepetition.push(initialSimplifiedFen);

            moveHistory.push({
                notation: (fen === START_FEN && !isSetupMode) ? "Initial Position" : (isSetupMode ? "Custom Setup" : "Loaded FEN"),
                fenBeforeMove: fen, 
                boardAfterMove: JSON.parse(JSON.stringify(boardState)), 
                from: null, to: null, 
                player: currentPlayer === 'white' ? 'black' : 'white', 
                capturedPiece: null,
                castlingRightsBeforeMove: {...castlingRights}, 
                castlingRightsAfterMove: {...castlingRights},  
                capturedByWhiteAfterMove: [], 
                capturedByBlackAfterMove: [],
                enPassantTargetBeforeMove: enPassantTargetSquare ? {...enPassantTargetSquare} : null,
                enPassantTargetAfterMove: enPassantTargetSquare ? {...enPassantTargetSquare} : null,
                halfmoveClockAfterMove: halfmoveClock, 
                fullmoveNumberAfterMove: fullmoveNumber
            });
            currentMoveIndexInHistory = 0; 


            updatePlayerInfoAndCapturedDisplays(); 
            deselectSquare(); 
            clearLastMoveHighlights(); 
           
            if (gameTimeMode > 0) { playerTimes.white = gameTimeMode; playerTimes.black = gameTimeMode; } 
            else { playerTimes.white = 0; playerTimes.black = 0; }
            updateClockDisplays(); 

            updateStatus(`${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}'s turn.`); 
           
            renderMoveHistory(); 
            drawCurrentArrows(); // Ensure canvas is clear

            if (gameTimeMode > 0 && !gameOver) { startClock(); }
            checkAIPlay(); 
        }

        // --- FEN Functionality ---
        function parseFEN(fen) {
            try {
                const parts = fen.split(" ");
                if (parts.length < 4) { 
                    console.error("Invalid FEN: Not enough parts.", fen);
                    showModalMessage("Invalid FEN string: Not enough parts.");
                    return false;
                }
                const piecePlacement = parts[0];
                const newBoard = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null));
                let rank = 0; 
                let file = 0; 

                for (const char of piecePlacement) {
                    if (char === '/') {
                        rank++;
                        file = 0;
                    } else if (/\d/.test(char)) {
                        file += parseInt(char);
                    } else {
                        if (rank < BOARD_SIZE && file < BOARD_SIZE) {
                            newBoard[rank][file] = char;
                        }
                        file++;
                    }
                }
                boardState = newBoard;

                currentPlayer = (parts[1] === 'w') ? 'white' : 'black';
               
                const fenCastle = parts[2];
                castlingRights = { K: false, Q: false, k: false, q: false }; 
                if (fenCastle !== '-') {
                    for (const char of fenCastle) {
                        if (char === 'K') castlingRights.K = true;
                        else if (char === 'Q') castlingRights.Q = true;
                        else if (char === 'k') castlingRights.k = true;
                        else if (char === 'q') castlingRights.q = true;
                    }
                }

                if (parts[3] === '-') {
                    enPassantTargetSquare = null;
                } else {
                    enPassantTargetSquare = fromAlgebraic(parts[3]); 
                    if (!enPassantTargetSquare) {
                         console.warn("Invalid en passant square in FEN:", parts[3]);
                         enPassantTargetSquare = null; 
                    }
                }
               
                halfmoveClock = parts[4] ? parseInt(parts[4]) : 0;
                fullmoveNumber = parts[5] ? parseInt(parts[5]) : 1;

                capturedByWhite = []; 
                capturedByBlack = [];
                lastMove = null; 
               
                createBoardUI(); 
                updatePlayerInfoAndCapturedDisplays();
                updateStatus(`${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}'s turn.`);
                clearLastMoveHighlights();
                deselectSquare();
                return true;
            } catch (e) {
                console.error("Error parsing FEN:", e, fen);
                showModalMessage("Error parsing FEN string. Please check format.");
                return false;
            }
        }

        function generateFENInternal() { 
            let fen = "";
            for (let r = 0; r < BOARD_SIZE; r++) {
                let emptyCount = 0;
                for (let f = 0; f < BOARD_SIZE; f++) {
                    const piece = boardState[r][f];
                    if (piece) {
                        if (emptyCount > 0) fen += emptyCount;
                        fen += piece;
                        emptyCount = 0;
                    } else {
                        emptyCount++;
                    }
                }
                if (emptyCount > 0) fen += emptyCount;
                if (r < BOARD_SIZE - 1) fen += '/';
            }

            fen += currentPlayer === 'white' ? " w " : " b ";
           
            let castleStr = "";
            if (castlingRights.K) castleStr += 'K';
            if (castlingRights.Q) castleStr += 'Q';
            if (castlingRights.k) castleStr += 'k';
            if (castlingRights.q) castleStr += 'q';
            fen += castleStr || "-";

            fen += " " + (enPassantTargetSquare ? getAlgebraic(enPassantTargetSquare.row, enPassantTargetSquare.col) : "-");
            fen += " " + halfmoveClock;
            fen += " " + fullmoveNumber;
            return fen;
        }

        // --- Threefold Repetition Logic ---
        function generateSimplifiedFENForRepetition(currentBoard, playerWhoseTurnItIs, currentCastlingRights, currentEnPassantTarget) {
            let fen = "";
            // 1. Piece placement
            for (let r = 0; r < BOARD_SIZE; r++) {
                let emptyCount = 0;
                for (let f = 0; f < BOARD_SIZE; f++) {
                    const piece = currentBoard[r][f];
                    if (piece) {
                        if (emptyCount > 0) fen += emptyCount;
                        fen += piece;
                        emptyCount = 0;
                    } else {
                        emptyCount++;
                    }
                }
                if (emptyCount > 0) fen += emptyCount;
                if (r < BOARD_SIZE - 1) fen += '/';
            }

            // 2. Active color
            fen += playerWhoseTurnItIs === 'white' ? " w" : " b";

            // 3. Castling availability
            let castleStr = "";
            if (currentCastlingRights.K) castleStr += 'K';
            if (currentCastlingRights.Q) castleStr += 'Q';
            if (currentCastlingRights.k) castleStr += 'k';
            if (currentCastlingRights.q) castleStr += 'q';
            fen += " " + (castleStr || "-");

            // 4. En passant target square
            fen += " " + (currentEnPassantTarget ? getAlgebraic(currentEnPassantTarget.row, currentEnPassantTarget.col) : "-");
           
            return fen;
        }

        function checkForThreefoldRepetition() {
            if (positionHistoryForRepetition.length < 3) return false; 

            const currentSimplifiedFen = positionHistoryForRepetition[positionHistoryForRepetition.length - 1];
            let count = 0;
            for (const fen of positionHistoryForRepetition) {
                if (fen === currentSimplifiedFen) {
                    count++;
                }
            }
            return count >= 3;
        }


        // --- Position Setup Functionality ---
        function populatePiecePalette() {
            piecePaletteDiv.innerHTML = '';
            PALETTE_PIECES_ORDER.forEach(pChar => {
                const paletteItem = document.createElement('div');
                paletteItem.classList.add('palette-piece');
                const img = document.createElement('img');
                img.src = PIECE_IMAGE_URLS[pChar];
                img.alt = PIECE_ALT_TEXT[pChar] || pChar;
                img.draggable = true; 
                paletteItem.appendChild(img);

                paletteItem.addEventListener('dragstart', (e) => {
                    draggedPalettePiece = pChar;
                });
                 paletteItem.addEventListener('dragend', (e) => {
                    draggedPalettePiece = null;
                });
                piecePaletteDiv.appendChild(paletteItem);
            });
        }

        function toggleSetupMode() {
            isSetupMode = !isSetupMode;
            if (isSetupMode) {
                stopClock();
                gameOver = true; 
                setupPositionBtn.textContent = "Exit Setup";
                setupPositionBtn.classList.add("bg-red-600", "hover:bg-red-700");
                setupPositionBtn.classList.remove("bg-gray-600", "hover:bg-gray-700"); 
                piecePaletteControlsDiv.classList.remove('hidden');
                statusMessageDiv.textContent = "Setup Mode: Drag pieces to board. Click board square to clear.";
                deselectSquare();
                clearLastMoveHighlights();
                arrowsOnBoard = []; 
                drawCurrentArrows();
            } else {
                setupPositionBtn.textContent = "Set Up Position";
                setupPositionBtn.classList.remove("bg-red-600", "hover:bg-red-700");
                setupPositionBtn.classList.add("bg-gray-600", "hover:bg-gray-700"); 
                piecePaletteControlsDiv.classList.add('hidden');
               
                const turnInput = prompt("Whose turn is it? (w/b)", currentPlayer === 'white' ? 'w' : 'b');
                currentPlayer = (turnInput && turnInput.toLowerCase() === 'b') ? 'black' : 'white';

                const castleInput = prompt("Castling rights? (e.g., KQkq, Kq, -)", 
                    (castlingRights.K ? "K" : "") + (castlingRights.Q ? "Q" : "") + 
                    (castlingRights.k ? "k" : "") + (castlingRights.q ? "q" : "") || "-"
                );
                castlingRights = { K: false, Q: false, k: false, q: false };
                if (castleInput && castleInput !== '-') {
                    if (castleInput.includes('K')) castlingRights.K = true;
                    if (castleInput.includes('Q')) castlingRights.Q = true;
                    if (castleInput.includes('k')) castlingRights.k = true;
                    if (castleInput.includes('q')) castlingRights.q = true;
                }

                const epInput = prompt("En passant target square? (e.g., e3 or -)", 
                    enPassantTargetSquare ? getAlgebraic(enPassantTargetSquare.row, enPassantTargetSquare.col) : "-"
                );
                if (epInput && epInput !== '-') {
                    enPassantTargetSquare = fromAlgebraic(epInput);
                     if (!enPassantTargetSquare) {
                          showModalMessage("Invalid EP square. EP target cleared.");
                    }
                } else {
                    enPassantTargetSquare = null;
                }

                const hmInput = prompt("Halfmove clock?", halfmoveClock);
                halfmoveClock = hmInput ? parseInt(hmInput) : 0;
                const fmInput = prompt("Fullmove number?", fullmoveNumber);
                fullmoveNumber = fmInput ? parseInt(fmInput) : 1;

                gameOver = false; 
                const setupFen = generateFENInternal(); 
                initializeGame(setupFen); 
            }
        }

        // --- AI Toggle Functionality ---
        function toggleAI(playerColor) {
            if (playerColor === 'white') {
                isWhiteAI = !isWhiteAI;
                toggleWhiteAiBtn.textContent = `White AI: ${isWhiteAI ? 'ON' : 'OFF'}`;
                toggleWhiteAiBtn.classList.toggle('active', isWhiteAI);
                toggleWhiteAiBtn.classList.toggle('inactive', !isWhiteAI);
            } else if (playerColor === 'black') {
                isBlackAI = !isBlackAI;
                toggleBlackAiBtn.textContent = `Black AI: ${isBlackAI ? 'ON' : 'OFF'}`;
                toggleBlackAiBtn.classList.toggle('active', isBlackAI);
                toggleBlackAiBtn.classList.toggle('inactive', !isBlackAI);
            }
            if (!gameOver && !isSetupMode && ((currentPlayer === 'white' && isWhiteAI) || (currentPlayer === 'black' && isBlackAI))) {
                checkAIPlay();
            }
        }

        async function checkAIPlay() {
            if (gameOver || isSetupMode || aiIsThinking) return;

            const aiToPlayNow = (currentPlayer === 'white' && isWhiteAI) || (currentPlayer === 'black' && isBlackAI);
           
            if (aiToPlayNow) {
                const aiMoveData = await fetchAIMoveFromPythonBackend(boardState, currentPlayer);
                if (aiMoveData && aiMoveData.fromSq && aiMoveData.toSq) {
                     const aiMoveResult = await sendMoveToBackend(
                        { actualBoardRow: aiMoveData.fromSq.row, actualBoardCol: aiMoveData.fromSq.col },
                        { actualBoardRow: aiMoveData.toSq.row, actualBoardCol: aiMoveData.toSq.col },
                        aiMoveData.promotionPiece,
                        aiMoveData.castling,
                        aiMoveData.isEnPassant
                    );
                    await processMoveResult(aiMoveResult, true); 
                } else if (aiMoveData && aiMoveData.message) { 
                    console.log("AI reports no moves or error: ", aiMoveData.message);
                    updateStatus(`AI (${currentPlayer}) reports: ${aiMoveData.message}`);
                    if (!hasAnyLegalMoves(boardState, currentPlayer)) {
                        const opponentColor = currentPlayer === 'white' ? 'black' : 'white';
                        if (isSquareAttacked(boardState, findKing(boardState, currentPlayer).row, findKing(boardState, currentPlayer).col, opponentColor )) {
                             showModalMessage(`Checkmate! ${opponentColor.charAt(0).toUpperCase() + opponentColor.slice(1)} wins.`);
                        } else {
                             showModalMessage("Stalemate! It's a draw.");
                        }
                        gameOver = true; stopClock();
                    }
                } else {
                    updateStatus(`AI (${currentPlayer}) did not return a valid move.`);
                }
            }
        }

        // --- Board Resizing Functionality ---
        function startResize(e) {
            e.preventDefault(); 
            isResizing = true;
            initialMouseX = e.clientX;
            initialMouseY = e.clientY;
            const currentDimension = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--current-board-dimension'));
            initialBoardWidth = currentDimension; 

            document.addEventListener('mousemove', doResize);
            document.addEventListener('mouseup', stopResize);
            document.body.style.cursor = 'nwse-resize'; 
        }

        function doResize(e) {
            if (!isResizing) return;

            const deltaX = e.clientX - initialMouseX;
           
            let newDimension = initialBoardWidth + deltaX; 

            const currentMax = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--dynamic-max-board-dimension'));
            newDimension = Math.max(MIN_BOARD_DIMENSION, newDimension);
            newDimension = Math.min(currentMax, newDimension); 

            document.documentElement.style.setProperty('--current-board-dimension', `${newDimension}px`);
        }

        function stopResize() {
            isResizing = false;
            document.removeEventListener('mousemove', doResize);
            document.removeEventListener('mouseup', stopResize);
            document.body.style.cursor = 'default'; 
        }
       
        function updateMaxBoardDimension() {
            MAX_BOARD_DIMENSION = Math.min(window.innerWidth - (240 + 40), window.innerHeight - 100); 
            document.documentElement.style.setProperty('--dynamic-max-board-dimension', `${Math.max(MIN_BOARD_DIMENSION, MAX_BOARD_DIMENSION)}px`);
            let currentDimension = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--current-board-dimension'));
            if (currentDimension > MAX_BOARD_DIMENSION) {
                 document.documentElement.style.setProperty('--current-board-dimension', `${MAX_BOARD_DIMENSION}px`);
            }
        }


        // --- Event Listeners ---
        flipBoardBtn.addEventListener('click', () => {
            boardFlipped = !boardFlipped;
            deselectSquare(); 
            createBoardUI(); 
            updatePlayerInfoAndCapturedDisplays(); 
        });

        newGameBtn.addEventListener('click', () => {
            initializeGame(START_FEN); // initializeGame now clears arrows
        }); 

        modalCloseButton.addEventListener('click', hideModal);
        window.addEventListener('click', (event) => { if (event.target === messageModal) hideModal(); });
       
        prevMoveBtn.addEventListener('click', () => {
            if (currentMoveIndexInHistory > 0) { 
                navigateToMoveInHistory(currentMoveIndexInHistory - 1);
            } 
        });
        nextMoveBtn.addEventListener('click', () => {
            if (currentMoveIndexInHistory < moveHistory.length - 1) {
                navigateToMoveInHistory(currentMoveIndexInHistory + 1);
            }
        });
        document.addEventListener('keydown', (event) => {
            if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') return; 
            if (event.key === "ArrowLeft") {
                prevMoveBtn.click();
            } else if (event.key === "ArrowRight") {
                nextMoveBtn.click();
            }
        });

        importFenBtn.addEventListener('click', () => {
            const fen = fenInput.value.trim();
            if (fen) {
                initializeGame(fen); // initializeGame now clears arrows
            } else {
                showModalMessage("FEN input is empty.");
            }
        });
        exportFenBtn.addEventListener('click', () => {
            exportedFenDisplay.value = generateFENInternal();
            fenExportModal.style.display = 'flex';
        });
        copyFenBtn.addEventListener('click', () => {
            exportedFenDisplay.select();
            document.execCommand('copy');
        });
        closeFenExportModalBtn.addEventListener('click', () => {
            fenExportModal.style.display = 'none';
        });
       
        setupPositionBtn.addEventListener('click', toggleSetupMode);
        clearBoardSetupBtn.addEventListener('click', () => {
            if (isSetupMode) {
                boardState = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(null));
                renderPieces();
                arrowsOnBoard = [];
                drawCurrentArrows();
            }
        });
        doneSettingUpBtn.addEventListener('click', () => {
            if (isSetupMode) {
                toggleSetupMode(); 
            }
        });

        toggleWhiteAiBtn.addEventListener('click', () => toggleAI('white'));
        toggleBlackAiBtn.addEventListener('click', () => toggleAI('black'));

        resizeHandle.addEventListener('mousedown', startResize);
        window.addEventListener('resize', updateMaxBoardDimension); 


        document.addEventListener('DOMContentLoaded', () => { 
            const initialBoardSizeCSS = getComputedStyle(document.documentElement).getPropertyValue('--current-board-dimension').trim();
            if (!initialBoardSizeCSS.endsWith('px')) { 
                 document.documentElement.style.setProperty('--current-board-dimension', '600px');
            }
            updateMaxBoardDimension(); 

            initializeArrowCanvas(); 

            chessboardDiv.addEventListener('contextmenu', handleBoardContextMenu); 
            chessboardDiv.addEventListener('mousedown', handleArrowMouseDown);   
            document.addEventListener('mousemove', handleArrowMouseMove);       
            document.addEventListener('mouseup', handleArrowMouseUp);           

            if (window.ResizeObserver) {
                const resizeObserver = new ResizeObserver(entries => {
                    for (let entry of entries) {
                        if (entry.target === chessboardWrapper) { 
                            resizeArrowCanvas();
                        }
                    }
                });
                resizeObserver.observe(chessboardWrapper); 
            } else {
                window.addEventListener('resize', resizeArrowCanvas);
            }


            initializeGame(START_FEN); 
            populatePiecePalette(); 
        });
    </script>
</body>
</html>
